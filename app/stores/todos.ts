import { ref, reactive } from "vue"
import { defineStore } from "pinia"
import type { Todo, TodoFilter } from "~~/shared/types"

// Database todo format (flat structure with children as IDs)
interface DbTodo {
  $id: string
  text: string
  completed: boolean
  children?: string[]
  expanded?: boolean
  priority?: 'low' | 'medium' | 'high'
  dueDate?: string
  createdAt?: string
  updatedAt?: string
}

// Utility functions for data transformation
const transformDbTodoToTodo = (dbTodos: DbTodo[]): Todo[] => {
  const todoMap = new Map<string, Todo>()
  const rootTodos: Todo[] = []

  // First pass: create all todos without children
  dbTodos.forEach(dbTodo => {
    const todo: Todo = {
      id: dbTodo.$id,
      text: dbTodo.text,
      completed: dbTodo.completed,
      expanded: dbTodo.expanded || false,
      priority: dbTodo.priority,
      dueDate: dbTodo.dueDate,
      createdAt: dbTodo.createdAt,
      updatedAt: dbTodo.updatedAt,
      children: []
    }
    todoMap.set(dbTodo.$id, todo)
  })

  // Second pass: build the hierarchy
  dbTodos.forEach(dbTodo => {
    const todo = todoMap.get(dbTodo.$id)!

    if (dbTodo.children && dbTodo.children.length > 0) {
      todo.children = dbTodo.children
        .map(childId => todoMap.get(childId))
        .filter(child => child !== undefined) as Todo[]
    }

    // If this todo is not a child of any other todo, it's a root todo
    const isChild = dbTodos.some(otherTodo =>
      otherTodo.children?.includes(dbTodo.$id)
    )

    if (!isChild) {
      rootTodos.push(todo)
    }
  })

  return rootTodos
}

const transformTodoToDbTodo = (todo: Todo): Omit<DbTodo, '$id'> => {
  return {
    text: todo.text,
    completed: todo.completed,
    children: todo.children?.map(child => child.id) || [],
    expanded: todo.expanded,
    priority: todo.priority,
    dueDate: todo.dueDate,
    createdAt: todo.createdAt,
    updatedAt: todo.updatedAt
  }
}

export const useTodosStore = defineStore('todos', () => {
  const todos = ref<Todo[]>([])
  const filter = ref<TodoFilter>('all')
  const searchQuery = ref<String>('')
  const loading = reactive<{
    fetch: boolean,
    submit: boolean,
  }>({
    fetch: false,
    submit: false,
  })

  const fetchTodos = async () => {
    try {
      const response = await $fetch<{ status: string; data: DbTodo[] }>('/api/todos')
      const dbTodos = response?.data || []
      todos.value = transformDbTodoToTodo(dbTodos)
    } catch (error) {
      console.error('Error fetching todos:', error)
    }
  }

  const setFilter = (newFilter: TodoFilter) => {
    filter.value = newFilter
  }

  const setLoading = (type: keyof typeof loading, value: boolean) => {
    loading[type] = value
  }

  const createTodo = async (todoData: Omit<Todo, 'id' | 'createdAt' | 'updatedAt'>) => {
    try {
      setLoading('submit', true)
      const response = await $fetch<{ status: string; data: DbTodo }>('/api/todos', {
        method: 'POST',
        body: transformTodoToDbTodo({
          ...todoData,
          id: '', // Will be generated by server
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        })
      })

      if (response.status === 'success') {
        // Refresh todos to get the updated list with proper hierarchy
        await fetchTodos()
      }

      return response.data
    } catch (error) {
      console.error('Error creating todo:', error)
      throw error
    } finally {
      setLoading('submit', false)
    }
  }

  const updateTodo = async (id: string, updateData: Partial<Omit<Todo, 'id' | 'createdAt'>>) => {
    try {
      setLoading('submit', true)
      const response = await $fetch<{ status: string; data: DbTodo }>(`/api/todos/${id}`, {
        method: 'PUT',
        body: {
          ...updateData,
          children: updateData.children?.map(child => child.id),
          updatedAt: new Date().toISOString()
        }
      })

      if (response.status === 'success') {
        // Refresh todos to get the updated list with proper hierarchy
        await fetchTodos()
      }

      return response.data
    } catch (error) {
      console.error('Error updating todo:', error)
      throw error
    } finally {
      setLoading('submit', false)
    }
  }

  const deleteTodo = async (id: string) => {
    try {
      setLoading('submit', true)
      const response = await $fetch<{ status: string; data: any }>(`/api/todos/${id}`, {
        method: 'DELETE'
      })

      if (response.status === 'success') {
        // Refresh todos to get the updated list
        await fetchTodos()
      }

      return response.data
    } catch (error) {
      console.error('Error deleting todo:', error)
      throw error
    } finally {
      setLoading('submit', false)
    }
  }

  const toggleCompleted = async (id: string) => {
    // Find the todo in the nested structure
    const findTodo = (todoList: Todo[]): Todo | null => {
      for (const todo of todoList) {
        if (todo.id === id) return todo
        if (todo.children) {
          const found = findTodo(todo.children)
          if (found) return found
        }
      }
      return null
    }

    const todo = findTodo(todos.value)
    if (todo) {
      await updateTodo(id, { completed: !todo.completed })
    }
  }

  const toggleExpanded = (id: string) => {
    // This is UI-only state, no API call needed
    const findAndToggle = (todoList: Todo[]): boolean => {
      for (const todo of todoList) {
        if (todo.id === id) {
          todo.expanded = !todo.expanded
          return true
        }
        if (todo.children && findAndToggle(todo.children)) {
          return true
        }
      }
      return false
    }

    findAndToggle(todos.value)
  }

  return {
    todos,
    filter,
    searchQuery,
    loading,
    fetchTodos,
    setFilter,
    setLoading,
    createTodo,
    updateTodo,
    deleteTodo,
    toggleCompleted,
    toggleExpanded,
  }
})
